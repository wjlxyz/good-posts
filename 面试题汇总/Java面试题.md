## 【精品问答】Java专业术语50问

* [【精品问答】Java专业术语50问](#精品问答java专业术语50问)
         * [1. StringBuffer和StringBuilder区别是什么？](#1-stringbuffer和stringbuilder区别是什么)
         * [2. 什么是线程安全？](#2-什么是线程安全)
         * [3. 什么是死锁？](#3-什么是死锁)
         * [4. synchronized的实现原理是什么？](#4-synchronized的实现原理是什么)
         * [5. 有了synchronized，还需要volatile做什么事？](#5-有了synchronized还需要volatile做什么事)
         * [6. synchronized的锁优化是怎么处理的？](#6-synchronized的锁优化是怎么处理的)
         * [7. JMM是什么？](#7-jmm是什么)
         * [8. Java并发包都有哪些，性能怎样？](#8-java并发包都有哪些性能怎样)
         * [9. 什么是fail-fast？](#9-什么是fail-fast)
         * [10. 什么是fail-safe？](#10-什么是fail-safe)
         * [11. 什么是CopyOnWrite？](#11-什么是copyonwrite)
         * [12. 什么是AQS呢？](#12-什么是aqs呢)
         * [13. 什么是CAS呢？](#13-什么是cas呢)
         * [14. 乐观锁是怎样的？](#14-乐观锁是怎样的)
         * [15. 乐观锁悲观锁区别是什么？](#15-乐观锁悲观锁区别是什么)
         * [16. 数据库如何实现悲观锁和乐观锁？](#16-数据库如何实现悲观锁和乐观锁)
         * [17. 数据库锁和隔离级别有什么关系？](#17-数据库锁和隔离级别有什么关系)
         * [18. 数据库锁和索引有什么关系？](#18-数据库锁和索引有什么关系)
         * [19. 什么是聚簇索引？](#19-什么是聚簇索引)
         * [20. 什么是非聚簇索引？](#20-什么是非聚簇索引)
         * [21. 索引最左前缀是什么？](#21-索引最左前缀是什么)
         * [22. 什么是B 树索引？](#22-什么是b树索引)
         * [23. 什么是联合索引？](#23-什么是联合索引)
         * [24. 什么是回表？](#24-什么是回表)
         * [25. 分布式锁有了解吗？](#25-分布式锁有了解吗)
         * [26. Redis怎么实现分布式锁？](#26-redis怎么实现分布式锁)
         * [27. 为什么要用Redis？](#27-为什么要用redis)
         * [28. Redis和memcache区别是什么？](#28-redis和memcache区别是什么)
         * [29. Zookeeper怎么实现分布式锁？](#29-zookeeper怎么实现分布式锁)
         * [30. 什么是Zookeeper？](#30-什么是zookeeper)
         * [31. 什么是CAP？](#31-什么是cap)
         * [32. 什么是BASE？和CAP什么区别？](#32-什么是base和cap什么区别)
         * [33. CAP怎么推导？如何取舍？](#33-cap怎么推导如何取舍)
         * [34. 分布式系统怎么保证数据一致性？](#34-分布式系统怎么保证数据一致性)
         * [35. 什么是分布式事务？分布式事务方案？](#35-什么是分布式事务分布式事务方案)
         * [36. 线程安全的单例？](#36-线程安全的单例)
         * [37. 不用synchronized和lock能实现线程安全的单例吗？](#37-不用synchronized和lock能实现线程安全的单例吗)
         * [38. 什么是Paxos算法？](#38-什么是paxos算法)
         * [39. ArrayList和LinkedList和Vector的区别](#39-arraylist和linkedlist和vector的区别)
         * [40. SynchronizedList和Vector的区别](#40-synchronizedlist和vector的区别)
         * [41. Arrays.asList获得的List使用时需要注意什么](#41-arraysaslist获得的list使用时需要注意什么)
         * [42. List和原始类型List之间的区别?](#42-list和原始类型list之间的区别)
         * [43. List&lt;?&gt;和List之间的区别是什么?](#43-list和list之间的区别是什么)
         * [44. synchronized是如何实现的？](#44-synchronized是如何实现的)
         * [45. BIO、NIO和AIO的区别、三种IO的用法与原理](#45-bionio和aio的区别三种io的用法与原理)
         * [46. ConcurrentSkipListMap](#46-concurrentskiplistmap)
         * [47. String.valueOf和Integer.toString的区别](#47-stringvalueof和integertostring的区别)
         * [48. Integer的缓存机制](#48-integer的缓存机制)
         * [49. Set如何保证元素不重复?](#49-set如何保证元素不重复)
         * [50. Java中如何保证线程安全？](#50-java中如何保证线程安全)

Java作为最流行的语言，一直占据着非常大的市场，但是很多遍Java程序员没有把Java基础的专业知识把握好，所以后期开发遇到问题非常多，下面来看一些Java常见的专业术语知识。

### 1. StringBuffer和StringBuilder区别是什么？

StringBuffer是线程安全的，而StringBuilder是非线程安全的。

### 2. 什么是线程安全？

当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。

### 3. 什么是死锁？

当两个或多个线程在等待彼此释放所需的资源(锁定)并陷入无限等待即是死锁。发生死锁的四个必要条件缺少一个就不会发生死锁：

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

### 4. synchronized的实现原理是什么？

Synchronized的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。

同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。

方法级的同步是隐式，即无需通过字节码指令来控制的。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。

### 5. 有了synchronized，还需要volatile做什么事？

一方面是因为synchronized是一种锁机制，存在阻塞问题和性能问题，而volatile并不是锁，所以不存在阻塞和性能问题。 另外一方面，因为volatile借助了内存屏障来帮助其解决可见性和有序性问题，而内存屏障的使用还为其带来了一个禁止指令重排的附件功能，所以在有些场景中是可以避免发生指令重排的问题的。

### 6. synchronized的锁优化是怎么处理的？

JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

自旋锁，就是让该线程等待一段时间，不会被立即挂起（就是不让前来获取该锁（已被占用）的线程立即阻塞），看持有锁的线程是否会很快释放锁。

适应自旋锁就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。

锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。

轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。

重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。

### 7. JMM是什么？

JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。

### 8. Java并发包都有哪些，性能怎样？

1、locks部分：包含在java.util.concurrent.locks包中，提供显式锁(互斥锁和速写锁)相关功能；

2、atomic部分：包含在java.util.concurrent.atomic包中，提供原子变量类相关的功能，是构建非阻塞算法的基础；

3、executor部分：散落在java.util.concurrent包中，提供线程池相关的功能；

4、collections部分：散落在java.util.concurrent包中，提供并发容器相关功能；

5、tools部分：散落在java.util.concurrent包中，提供同步工具类，如信号量、闭锁、栅栏等功能；

### 9. 什么是fail-fast？

在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException。

原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hasNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。

场景：java.utl包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

### 10. 什么是fail-safe？

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问，而是先复制原有集合内容，在拷贝的集合上进行遍历，所以在修改集合上层元素不会影响下层。在java.util.concurrent下都是安全的。

### 11. 什么是CopyOnWrite？

CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

### 12. 什么是AQS呢？

AQS(AbstractQueuedSynchronizer)同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列。它的子类必须重写AQS的几个protected修饰的用来改变同步状态的方法，其他方法主要是实现了排队和阻塞机制。状态的更新使用getState,setState以及compareAndSetState这三个方法。 子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。 同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。锁和同步器很好的隔离了使用者和实现者所需关注的领域。

### 13. 什么是CAS呢？

当多个线程同时对某个资源进行CAS操作，只能有一个线程操作成功，但是并不会阻塞其他线程,其他线程只会收到操作失败的信号。可见 CAS 其实是一个乐观锁。

CAS的两个缺点： ABA 的问题，就是一个值从A变成了B又变成了A，使用CAS操作不能发现这个值发生变化了，处理方式是可以使用携带类似时间戳的版本AtomicStampedReference 性能问题，我们使用时大部分时间使用的是 while true 方式对数据的修改，直到成功为止。优势就是相应极快，但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。

### 14. 乐观锁是怎样的？

乐观锁顾名思义就是在操作时很乐观，认为操作不会产生并发问题(不会有其他线程对数据进行修改)，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS(compare and swap)算法实现。

### 15. 乐观锁悲观锁区别是什么？

**悲观锁(Pessimistic Lock)** 在每次拿数据时都会上锁，传统的关系型数据库里边经常用到用到比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，主要依靠数据库提供的锁机制。

**乐观锁(Optimistic Lock)** 每次拿数据的时候都不会上锁，在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

**区别** 两种锁各有优缺点，乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。悲观锁适用于经常产生冲突，上层应用会不断的进行retry。


### 16. 数据库如何实现悲观锁和乐观锁？

乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。

通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。

悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作。

数据库有实现悲观锁，共享锁和排它锁就是两种实现方式。共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁，在执行语句后面加上lock in share mode就代表对某些资源加上共享锁了。排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁，在需要执行的语句后面加上for update就可以了

### 17. 数据库锁和隔离级别有什么关系？

数据库的四种隔离级别： 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读) 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，**锁的应用最终导致不同事务的隔离级别**

MVCC(Multi-Version Concurrency Control)多版本并发控制，可以简单地认为：**MVCC就是行级锁的一个变种(升级版)**。

- 事务的隔离级别就是**通过锁的机制来实现**，只不过**隐藏了加锁细节**

在**表锁中我们读写是阻塞**的，基于提升并发性能的考虑，**MVCC一般读写是不阻塞的**(所以说MVCC很多情况下避免了加锁的操作)

- MVCC实现的**读写不阻塞**正如其名：**多版本**并发控制--->通过一定机制生成一个数据请求**时间点的一致性数据快照（Snapshot)**，并用这个快照来提供一定级别（**语句级或事务级**）的**一致性读取**。从用户的角度来看，好像是**数据库可以提供同一数据的多个版本**。

### 18. 数据库锁和索引有什么关系？

mysql innodb的锁是通过锁索引来实现的。

排它锁举例：

1. 如果字段没有索引，即使使用wehre条件也会进行表级锁
2. 如果有索引，会锁定对应where条件中索引值的所有行，可理解为对该索引值进行了索引（所以即使另一事务查询的是其他行，但因为索引值相同它们也会被锁住。）
3. 有索引，而且使用了不同的索引值查数据，但是查询 的结果是同一行，可以理解为真正的数据行锁。

### 19. 什么是聚簇索引？

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。比如，InnoDB的聚簇索引使用B+Tree的数据结构存储索引和数据。

聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。

- 特点是存储数据的顺序和索引顺序一致。
- 一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。

当表有聚簇索引时，它的数据行实际上存放在索引的叶子页(leaf page)中。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（不过，覆盖索引可以模拟多个聚簇索引的情况）。

- 术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。
- 聚簇索引的二级索引：叶子节点不会保存引用的行的物理位置，而是保存行的主键值。

### 20. 什么是非聚簇索引？

MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。

非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

### 21. 索引最左前缀是什么？

在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

在建立联合索引时，先按照从左边起第一个字段进行排序，然后前一个字段同值时按照下一个字段排序。

对于联合索引(col1,col2,col3)，查询语句SELECT * FROM test WHERE col2=2;是否能够触发索引？

```
EXPLAIN SELECT * FROM test WHERE col2=2;
EXPLAIN SELECT * FROM test WHERE col1=1;
```

观察上述两个explain结果中的type字段。查询中分别是：

1. type: index
2. type: ref

**index**：这种类型表示mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个**联合索引的一部分**，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。
**ref**：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，**也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。**

### 22. 什么是B+树索引？

B+树有以下特点： 

1. B+树是一棵搜索树，树中元素是有序的。
2. B+树是B树的变体。优势在于硬盘IO次数更少（因为中间节点只是指针，不保存其他数据，所以一个节点能存储更多元素，使得整棵树更胖更矮），而且便于范围查找。
3. B+树往往很大，不能完全存放于内盘，需要存放于硬盘，所以IO次数决定效率。
4. 一个节点可以包含多个元素，减小树的高度，这样一次硬盘IO能读过较多元素，能减少IO次数。
5. 根节点至少有两个值。
6. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
7. 父节点的元素是孩子结点中最大（或最小）的元素。所以根节点的最大元素是整棵树的最大元素。
8. 每个一个父结点的元素都会出现在孩子结点中，所以叶子节点中包含树中所有元素。
9. 所有的叶子结点都位于同一层。
10. 每个叶子节点包含指向下个叶子节点的指针，形成一个有序链表。
11. 只有叶子节点包含数据库中的数据（卫星数据），其他节点都是索引。
12. 聚集索引存在的是一条记录，非聚集索引存放的是主键。

### 23. 什么是联合索引？

联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持**a** | **a,b**| **a,b,c** 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。

### 24. 什么是回表？

先索引扫描，再通过ID去取索引中未能提供的数据，即为回表。所以，基于非主键索引的查询需要多扫描一棵索引树。

### 25. 分布式锁有了解吗？

分布式锁的特点:

- 互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。
- 可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。
- 锁超时:和本地锁一样支持锁超时，防止死锁。
- 高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。
- 支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。
- 支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。

实现分布式锁的一般方式：

- MySql
- Zk
- Redis
- 自研分布式锁:如谷歌的Chubby。

### 26. Redis怎么实现分布式锁？

set resourceName value ex 5 nx 

### 27. 为什么要用Redis？

- 速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；
- 丰富的数据类型，Redis有8种数据类型，当然常用的主要是 String、Hash、List、Set、 SortSet 这5种类型，他们都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求，如果有特殊需求还能自己通过 lua 脚本自己创建新的命令（具备原子性）；
- Redis还提供了像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。
- 还支持事务、持久化、主从复制让高可用、分布式成为可能。

Redis适用场景：

- 缓存
- 排行榜：适用SortSet数据结构
- 计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；
- 好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；
- 简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；
- Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。

### 28. Redis和memcache区别是什么？

集群：redis 和memcached都支持集群

数据类型：Redis支持的数据类型要丰富得多,Redis不仅仅支持简单的k/v类型的数据，同时还提供String，List,Set,Hash,Sorted Set,pub/sub,Transactions数据结构的存储。其中Set是HashMap实现的，value永远为null而已；memcache支持简单数据类型，需要客户端自己处理复杂对象 

持久性：redis支持数据落地持久化存储,可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 

分布式存储：redis支持master-slave复制模式；memcache可以使用一致性hash做分布式

value大小不同：memcache是一个内存缓存，key的长度小于250字符**，单个item存储要小于1M**，不适合虚拟机使用

数据一致性不同：Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。 redis使用的是单线程模型，保证了数据按顺序提交。memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作 

cpu利用：redis单线程模型只能使用一个cpu，可以开启多个redis进程

### 29. Zookeeper怎么实现分布式锁？
假设锁空间的根节点为/lock，
1. 客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推。
2. 客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听刚好在自己之前一位的子节点删除消息，获得子节点变更通知后重复此步骤直至获得锁；
3. 执行业务代码；
4. 完成业务流程后，删除对应的子节点释放锁。

### 30. 什么是Zookeeper？
Zookeeper（业界简称zk）是一种提供配置管理、分布式协同以及命名的中心化服务，这些提供的功能都是分布式系统中非常底层且必不可少的基本功能，但是如果自己实现这些功能而且要达到高吞吐、低延迟同时还要保持一致性和可用性，实际上非常困难。因此zookeeper提供了这些功能，开发者在zookeeper之上构建自己的各种分布式系统。

虽然zookeeper的实现比较复杂，但是它提供的模型抽象却是非常简单的。Zookeeper提供一个多层级的节点命名空间（节点称为znode），每个节点都用一个以斜杠（/）分隔的路径表示，而且每个节点都有父节点（根节点除外），非常类似于文件系统。例如，/foo/doo这个表示一个znode，它的父节点为/foo，父父节点为/，而/为根节点没有父节点。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。

### 31. 什么是CAP？
CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以，一致性，说的就是数据一致性。CAP的一致性指的是强一致性。
可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。
分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

### 32. 什么是BASE？和CAP什么区别？
BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。

BASE定理是对CAP定理的延伸：即使无法做到强一致性（Strong Consistency），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。CAP中提到的一致性是强一致性，所谓“牺牲一致性”指牺牲强一致性保证弱一致性。

基本可用：出现故障的时候，允许损失部分可用性，即，保证核心可用。
软状态：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。
最终一致性：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。

### 33. CAP怎么推导？如何取舍？
CA without P：这种情况在分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。这也是为什么在前面的CAP证明中，我们以系统满足P为前提论述了无法同时满足C和A。
CP without A：如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。
AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。

### 34. 分布式系统怎么保证数据一致性？

### 35. 什么是分布式事务？分布式事务方案？

### 36. 线程安全的单例？

### 37. 不用synchronized和lock能实现线程安全的单例吗？

### 38. 什么是Paxos算法？

### 39. ArrayList和LinkedList和Vector的区别

### 40. SynchronizedList和Vector的区别

### 41. Arrays.asList获得的List使用时需要注意什么

### 42. List和原始类型List之间的区别?

### 43. List<?>和List之间的区别是什么?

### 44. synchronized是如何实现的？

### 45. BIO、NIO和AIO的区别、三种IO的用法与原理

### 46. ConcurrentSkipListMap

### 47. String.valueOf和Integer.toString的区别

### 48. Integer的缓存机制

### 49. Set如何保证元素不重复?

### 50. Java中如何保证线程安全？

