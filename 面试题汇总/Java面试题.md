## 【精品问答】Java专业术语50问

* [【精品问答】Java专业术语50问](#精品问答java专业术语50问)
         * [1. StringBuffer和StringBuilder区别是什么？](#1-stringbuffer和stringbuilder区别是什么)
         * [2. 什么是线程安全？](#2-什么是线程安全)
         * [3. 什么是死锁？](#3-什么是死锁)
         * [4. synchronized的实现原理是什么？](#4-synchronized的实现原理是什么)
         * [5. 有了synchronized，还需要volatile做什么事？](#5-有了synchronized还需要volatile做什么事)
         * [6. synchronized的锁优化是怎么处理的？](#6-synchronized的锁优化是怎么处理的)
         * [7. JMM是什么？](#7-jmm是什么)
         * [8. Java并发包都有哪些，性能怎样？](#8-java并发包都有哪些性能怎样)
         * [9. 什么是fail-fast？](#9-什么是fail-fast)
         * [10. 什么是fail-safe？](#10-什么是fail-safe)
         * [11. 什么是CopyOnWrite？](#11-什么是copyonwrite)
         * [12. 什么是AQS呢？](#12-什么是aqs呢)
         * [13. 什么是CAS呢？](#13-什么是cas呢)
         * [14. 乐观锁是怎样的？](#14-乐观锁是怎样的)
         * [15. 乐观锁悲观锁区别是什么？](#15-乐观锁悲观锁区别是什么)
         * [16. 数据库如何实现悲观锁和乐观锁？](#16-数据库如何实现悲观锁和乐观锁)
         * [17. 数据库锁和隔离级别有什么关系？](#17-数据库锁和隔离级别有什么关系)
         * [18. 数据库锁和索引有什么关系？](#18-数据库锁和索引有什么关系)
         * [19. 什么是聚簇索引？](#19-什么是聚簇索引)
         * [20. 什么是非聚簇索引？](#20-什么是非聚簇索引)
         * [21. 索引最左前缀是什么？](#21-索引最左前缀是什么)
         * [22. 什么是B 树索引？](#22-什么是b树索引)
         * [23. 什么是联合索引？](#23-什么是联合索引)
         * [24. 什么是回表？](#24-什么是回表)
         * [25. 分布式锁有了解吗？](#25-分布式锁有了解吗)
         * [26. Redis怎么实现分布式锁？](#26-redis怎么实现分布式锁)
         * [27. 为什么要用Redis？](#27-为什么要用redis)
         * [28. Redis和memcache区别是什么？](#28-redis和memcache区别是什么)
         * [29. Zookeeper怎么实现分布式锁？](#29-zookeeper怎么实现分布式锁)
         * [30. 什么是Zookeeper？](#30-什么是zookeeper)
         * [31. 什么是CAP？](#31-什么是cap)
         * [32. 什么是BASE？和CAP什么区别？](#32-什么是base和cap什么区别)
         * [33. CAP怎么推导？如何取舍？](#33-cap怎么推导如何取舍)
         * [34. 分布式系统怎么保证数据一致性？](#34-分布式系统怎么保证数据一致性)
         * [35. 什么是分布式事务？分布式事务方案？](#35-什么是分布式事务分布式事务方案)
         * [36. 线程安全的单例？](#36-线程安全的单例)
         * [37. 不用synchronized和lock能实现线程安全的单例吗？](#37-不用synchronized和lock能实现线程安全的单例吗)
         * [38. 什么是Paxos算法？](#38-什么是paxos算法)
         * [39. ArrayList和LinkedList和Vector的区别](#39-arraylist和linkedlist和vector的区别)
         * [40. SynchronizedList和Vector的区别](#40-synchronizedlist和vector的区别)
         * [41. Arrays.asList获得的List使用时需要注意什么](#41-arraysaslist获得的list使用时需要注意什么)
         * [42. List和原始类型List之间的区别?](#42-list和原始类型list之间的区别)
         * [43. List&lt;?&gt;和List之间的区别是什么?](#43-list和list之间的区别是什么)
         * [44. synchronized是如何实现的？](#44-synchronized是如何实现的)
         * [45. BIO、NIO和AIO的区别、三种IO的用法与原理](#45-bionio和aio的区别三种io的用法与原理)
         * [46. ConcurrentSkipListMap](#46-concurrentskiplistmap)
         * [47. String.valueOf和Integer.toString的区别](#47-stringvalueof和integertostring的区别)
         * [48. Integer的缓存机制](#48-integer的缓存机制)
         * [49. Set如何保证元素不重复?](#49-set如何保证元素不重复)
         * [50. Java中如何保证线程安全？](#50-java中如何保证线程安全)

Java作为最流行的语言，一直占据着非常大的市场，但是很多遍Java程序员没有把Java基础的专业知识把握好，所以后期开发遇到问题非常多，下面来看一些Java常见的专业术语知识。

### 1. StringBuffer和StringBuilder区别是什么？

StringBuffer是线程安全的，而StringBuilder是非线程安全的。

### 2. 什么是线程安全？

当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。

### 3. 什么是死锁？

当两个或多个线程在等待彼此释放所需的资源(锁定)并陷入无限等待即是死锁。发生死锁的四个必要条件缺少一个就不会发生死锁：

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

### 4. synchronized的实现原理是什么？

Synchronized的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。

同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。

方法级的同步是隐式，即无需通过字节码指令来控制的。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。

### 5. 有了synchronized，还需要volatile做什么事？

一方面是因为synchronized是一种锁机制，存在阻塞问题和性能问题，而volatile并不是锁，所以不存在阻塞和性能问题。 另外一方面，因为volatile借助了内存屏障来帮助其解决可见性和有序性问题，而内存屏障的使用还为其带来了一个禁止指令重排的附件功能，所以在有些场景中是可以避免发生指令重排的问题的。

### 6. synchronized的锁优化是怎么处理的？

JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

自旋锁，就是让该线程等待一段时间，不会被立即挂起（就是不让前来获取该锁（已被占用）的线程立即阻塞），看持有锁的线程是否会很快释放锁。

适应自旋锁就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。

锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。

轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。

重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。

### 7. JMM是什么？

JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。

### 8. Java并发包都有哪些，性能怎样？

1、locks部分：包含在java.util.concurrent.locks包中，提供显式锁(互斥锁和速写锁)相关功能；

2、atomic部分：包含在java.util.concurrent.atomic包中，提供原子变量类相关的功能，是构建非阻塞算法的基础；

3、executor部分：散落在java.util.concurrent包中，提供线程池相关的功能；

4、collections部分：散落在java.util.concurrent包中，提供并发容器相关功能；

5、tools部分：散落在java.util.concurrent包中，提供同步工具类，如信号量、闭锁、栅栏等功能；

### 9. 什么是fail-fast？

在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException。

原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hasNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。

场景：java.utl包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

### 10. 什么是fail-safe？

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问，而是先复制原有集合内容，在拷贝的集合上进行遍历，所以在修改集合上层元素不会影响下层。在java.util.concurrent下都是安全的。

### 11. 什么是CopyOnWrite？

CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

### 12. 什么是AQS呢？

AQS(AbstractQueuedSynchronizer)同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列。它的子类必须重写AQS的几个protected修饰的用来改变同步状态的方法，其他方法主要是实现了排队和阻塞机制。状态的更新使用getState,setState以及compareAndSetState这三个方法。 子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。 同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。锁和同步器很好的隔离了使用者和实现者所需关注的领域。

### 13. 什么是CAS呢？

当多个线程同时对某个资源进行CAS操作，只能有一个线程操作成功，但是并不会阻塞其他线程,其他线程只会收到操作失败的信号。可见 CAS 其实是一个乐观锁。

CAS的两个缺点： ABA 的问题，就是一个值从A变成了B又变成了A，使用CAS操作不能发现这个值发生变化了，处理方式是可以使用携带类似时间戳的版本AtomicStampedReference 性能问题，我们使用时大部分时间使用的是 while true 方式对数据的修改，直到成功为止。优势就是相应极快，但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。

### 14. 乐观锁是怎样的？

乐观锁顾名思义就是在操作时很乐观，认为操作不会产生并发问题(不会有其他线程对数据进行修改)，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS(compare and swap)算法实现。

### 15. 乐观锁悲观锁区别是什么？

**悲观锁(Pessimistic Lock)** 在每次拿数据时都会上锁，传统的关系型数据库里边经常用到用到比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，主要依靠数据库提供的锁机制。

**乐观锁(Optimistic Lock)** 每次拿数据的时候都不会上锁，在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

**区别** 两种锁各有优缺点，乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。悲观锁适用于经常产生冲突，上层应用会不断的进行retry。


### 16. 数据库如何实现悲观锁和乐观锁？

乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。

通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。

悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作。

数据库有实现悲观锁，共享锁和排它锁就是两种实现方式。共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁，在执行语句后面加上lock in share mode就代表对某些资源加上共享锁了。排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁，在需要执行的语句后面加上for update就可以了

### 17. 数据库锁和隔离级别有什么关系？

数据库的四种隔离级别： 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读) 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，**锁的应用最终导致不同事务的隔离级别**

MVCC(Multi-Version Concurrency Control)多版本并发控制，可以简单地认为：**MVCC就是行级锁的一个变种(升级版)**。

- 事务的隔离级别就是**通过锁的机制来实现**，只不过**隐藏了加锁细节**

在**表锁中我们读写是阻塞**的，基于提升并发性能的考虑，**MVCC一般读写是不阻塞的**(所以说MVCC很多情况下避免了加锁的操作)

- MVCC实现的**读写不阻塞**正如其名：**多版本**并发控制--->通过一定机制生成一个数据请求**时间点的一致性数据快照（Snapshot)**，并用这个快照来提供一定级别（**语句级或事务级**）的**一致性读取**。从用户的角度来看，好像是**数据库可以提供同一数据的多个版本**。

### 18. 数据库锁和索引有什么关系？

mysql innodb的锁是通过锁索引来实现的。

排它锁举例：

1. 如果字段没有索引，即使使用wehre条件也会进行表级锁
2. 如果有索引，会锁定对应where条件中索引值的所有行，可理解为对该索引值进行了索引（所以即使另一事务查询的是其他行，但因为索引值相同它们也会被锁住。）
3. 有索引，而且使用了不同的索引值查数据，但是查询 的结果是同一行，可以理解为真正的数据行锁。

### 19. 什么是聚簇索引？

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。比如，InnoDB的聚簇索引使用B+Tree的数据结构存储索引和数据。

聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。

- 特点是存储数据的顺序和索引顺序一致。
- 一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。

当表有聚簇索引时，它的数据行实际上存放在索引的叶子页(leaf page)中。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（不过，覆盖索引可以模拟多个聚簇索引的情况）。

- 术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。
- 聚簇索引的二级索引：叶子节点不会保存引用的行的物理位置，而是保存行的主键值。

### 20. 什么是非聚簇索引？

MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。

非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

### 21. 索引最左前缀是什么？

在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

在建立联合索引时，先按照从左边起第一个字段进行排序，然后前一个字段同值时按照下一个字段排序。

对于联合索引(col1,col2,col3)，查询语句SELECT * FROM test WHERE col2=2;是否能够触发索引？

```
EXPLAIN SELECT * FROM test WHERE col2=2;
EXPLAIN SELECT * FROM test WHERE col1=1;
```

观察上述两个explain结果中的type字段。查询中分别是：

1. type: index
2. type: ref

**index**：这种类型表示mysql会对整个该索引进行扫描。要想用到这种类型的索引，对这个索引并无特别要求，只要是索引，或者某个**联合索引的一部分**，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。所以，上述语句会触发索引。
**ref**：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。简单说，**也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。**

### 22. 什么是B+树索引？

B+树有以下特点： 

1. B+树是一棵搜索树，树中元素是有序的。
2. B+树是B树的变体。优势在于硬盘IO次数更少（因为中间节点只是指针，不保存其他数据，所以一个节点能存储更多元素，使得整棵树更胖更矮），而且便于范围查找。
3. B+树往往很大，不能完全存放于内盘，需要存放于硬盘，所以IO次数决定效率。
4. 一个节点可以包含多个元素，减小树的高度，这样一次硬盘IO能读过较多元素，能减少IO次数。
5. 根节点至少有两个值。
6. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
7. 父节点的元素是孩子结点中最大（或最小）的元素。所以根节点的最大元素是整棵树的最大元素。
8. 每个一个父结点的元素都会出现在孩子结点中，所以叶子节点中包含树中所有元素。
9. 所有的叶子结点都位于同一层。
10. 每个叶子节点包含指向下个叶子节点的指针，形成一个有序链表。
11. 只有叶子节点包含数据库中的数据（卫星数据），其他节点都是索引。
12. 聚集索引存在的是一条记录，非聚集索引存放的是主键。

### 23. 什么是联合索引？

联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持**a** | **a,b**| **a,b,c** 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。

### 24. 什么是回表？

先索引扫描，再通过ID去取索引中未能提供的数据，即为回表。所以，基于非主键索引的查询需要多扫描一棵索引树。

### 25. 分布式锁有了解吗？

分布式锁的特点:

- 互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。
- 可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。
- 锁超时:和本地锁一样支持锁超时，防止死锁。
- 高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。
- 支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。
- 支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。

实现分布式锁的一般方式：

- MySql
- Zk
- Redis
- 自研分布式锁:如谷歌的Chubby。

### 26. Redis怎么实现分布式锁？

set resourceName value ex 5 nx 

### 27. 为什么要用Redis？

- 速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；
- 丰富的数据类型，Redis有8种数据类型，当然常用的主要是 String、Hash、List、Set、 SortSet 这5种类型，他们都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求，如果有特殊需求还能自己通过 lua 脚本自己创建新的命令（具备原子性）；
- Redis还提供了像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。
- 还支持事务、持久化、主从复制让高可用、分布式成为可能。

Redis适用场景：

- 缓存
- 排行榜：适用SortSet数据结构
- 计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；
- 好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；
- 简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；
- Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。

### 28. Redis和memcache区别是什么？

集群：redis 和memcached都支持集群

数据类型：Redis支持的数据类型要丰富得多,Redis不仅仅支持简单的k/v类型的数据，同时还提供String，List,Set,Hash,Sorted Set,pub/sub,Transactions数据结构的存储。其中Set是HashMap实现的，value永远为null而已；memcache支持简单数据类型，需要客户端自己处理复杂对象 

持久性：redis支持数据落地持久化存储,可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 

分布式存储：redis支持master-slave复制模式；memcache可以使用一致性hash做分布式

value大小不同：memcache是一个内存缓存，key的长度小于250字符**，单个item存储要小于1M**，不适合虚拟机使用

数据一致性不同：Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。 redis使用的是单线程模型，保证了数据按顺序提交。memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作 

cpu利用：redis单线程模型只能使用一个cpu，可以开启多个redis进程

### 29. Zookeeper怎么实现分布式锁？
假设锁空间的根节点为/lock，
1. 客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推。
2. 客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听刚好在自己之前一位的子节点删除消息，获得子节点变更通知后重复此步骤直至获得锁；
3. 执行业务代码；
4. 完成业务流程后，删除对应的子节点释放锁。

### 30. 什么是Zookeeper？
Zookeeper（业界简称zk）是一种提供配置管理、分布式协同以及命名的中心化服务，这些提供的功能都是分布式系统中非常底层且必不可少的基本功能，但是如果自己实现这些功能而且要达到高吞吐、低延迟同时还要保持一致性和可用性，实际上非常困难。因此zookeeper提供了这些功能，开发者在zookeeper之上构建自己的各种分布式系统。

虽然zookeeper的实现比较复杂，但是它提供的模型抽象却是非常简单的。Zookeeper提供一个多层级的节点命名空间（节点称为znode），每个节点都用一个以斜杠（/）分隔的路径表示，而且每个节点都有父节点（根节点除外），非常类似于文件系统。例如，/foo/doo这个表示一个znode，它的父节点为/foo，父父节点为/，而/为根节点没有父节点。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。

### 31. 什么是CAP？
CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以，一致性，说的就是数据一致性。CAP的一致性指的是强一致性。
可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。
分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

### 32. 什么是BASE？和CAP什么区别？
BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。

BASE定理是对CAP定理的延伸：即使无法做到强一致性（Strong Consistency），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。CAP中提到的一致性是强一致性，所谓“牺牲一致性”指牺牲强一致性保证弱一致性。

基本可用：出现故障的时候，允许损失部分可用性，即，保证核心可用。
软状态：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。
最终一致性：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。

### 33. CAP怎么推导？如何取舍？
CA without P：这种情况在分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。这也是为什么在前面的CAP证明中，我们以系统满足P为前提论述了无法同时满足C和A。
CP without A：如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。
AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。

### 34. 分布式系统怎么保证数据一致性？
基于XA协议的二阶段提交
消息事务+最终一致性
TCC编程模式

1、分布式事务

要想理解分布式事务，我们需要先介绍一下两阶段提交协议。

两阶段提交协议（Two-phase Commit，2PC）经常被用来实现分布式事务。一般分为协调器和若干事务执行者两种角色。这里的事务执行者就是具体的数据库，抽象点可以说是可以控制给数据库的程序。 协调器可以和事务执行器在一台机器上。

在分布式系统中，每个节点虽然可以知晓自己的操作的成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)。

2、非事务型消息队列+本地消息表

此方案关键是要有个本地消息表，基本思路就是：

消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交。
消息消费方：处理消息并完成自己的业务逻辑。此时如果本地事务处理成功，那发送给生产方一个confirm消息，表明已经处理成功了。如果处理失败，则将消息放回MQ。
生产方定时扫描本地消息表，把还没处理完成的消息重新发送一遍，直到本地消息表中记录的该消息为已成功状态。

3、事务型消息队列

事务型消息实际上是一个很理想的想法，目前市面上大部分MQ都不支持事务消息，其中包括目前比较火的kafka。阿里的RocketMQ是可以支持事务型消息的MQ，根据网传的资料，大概了解到RocketMQ的事务消息相当于在普通MQ的基础上，提供了2PC的提交接口。把非事务型消息队列中的消息状态和重发等用中间件形式封装了。

### 35. 什么是分布式事务？分布式事务方案？
分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

基于XA协议的二阶段提交
在XA协议中分为两阶段:
第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.
第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。
缺点：单点问题，同步阻塞，数据不一致

TCC编程模式:TCC（Try-Confirm-Cancel）
对于TCC的解释:
Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）
Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。
Cancel阶段：取消执行，释放Try阶段预留的业务资源
Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。

### 36. 线程安全的单例？
内部类、双重检查、枚举类

### 37. 不用synchronized和lock能实现线程安全的单例吗？
如果不那么吹毛求疵的话，可以使用枚举、静态内部类以及饿汉模式来实现单例模式。但是，上面这几种方法其实底层也都用到了synchronized。

在JDK1.5 中新增java.util.concurrent(J.U.C)就是建立在CAS之上的。相对于对于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。

public class Singleton {
    private static final AtomicReference<Singleton> INSTANCE = new AtomicReference<Singleton>(); 

    private Singleton() {}

    public static Singleton getInstance() {
        for (;;) {
            Singleton singleton = INSTANCE.get();
            if (null != singleton) {
                return singleton;
            }

            singleton = new Singleton();
            if (INSTANCE.compareAndSet(null, singleton)) {
                return singleton;
            }
        }
    }
}

用CAS的好处在于不需要使用传统的锁机制来保证线程安全,CAS是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度。
CAS的一个重要缺点在于如果忙等待一直执行不成功(一直在死循环中),会对CPU造成较大的执行开销。

### 38. 什么是Paxos算法？
Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。
在Paxos算法中，有三种角色：

Proposer
Acceptor
Learners
在具体的实现中，一个进程可能同时充当多种角色。比如一个进程可能既是Proposer又是Acceptor又是Learner。
还有一个很重要的概念叫提案（Proposal）。最终要达成一致的value就在提案里。

注：
暂且认为『提案=value』，即提案只包含value。在我们接下来的推导过程中会发现如果提案只包含value，会有问题，于是我们再对提案重新设计。
暂且认为『Proposer可以直接提出提案』。在我们接下来的推导过程中会发现如果Proposer直接提出提案会有问题，需要增加一个学习提案的过程。
Proposer可以提出（propose）提案；Acceptor可以接受（accept）提案；如果某个提案被选定（chosen），那么该提案里的value就被选定了。

回到刚刚说的『对某个数据的值达成一致』，指的是Proposer、Acceptor、Learner都认为同一个value被选定（chosen）。那么，Proposer、Acceptor、Learner分别在什么情况下才能认为某个value被选定呢？

Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。
Acceptor：只要Acceptor接受了某个提案，Acceptor就任务该提案里的value被选定了。
Learner：Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。

### 39. ArrayList和LinkedList和Vector的区别
ArrayList 本质上是一个可改变大小的数组.当元素加入时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问.元素顺序存储 ,随机访问很快，删除非头尾元素慢，新增元素慢而且费资源 ,较适用于无频繁增删的情况 ,比数组效率低，如果不是需要可变数组，可考虑使用数组 ,非线程安全.
LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList. 适用于 ：没有大规模的随机读取，有大量的增加/删除操作.随机访问很慢，增删操作很快，不耗费多余资源 ,允许null元素,非线程安全.
Vector （类似于ArrayList）但其是同步的，开销就比ArrayList要大。如果你的程序本身是线程安全的，那么使用ArrayList是更好的选择。 Vector和ArrayList在更多元素添加进来时会请求更大的空间。Vector每次请求其大小的双倍空间，而ArrayList每次对size增长50%.

### 40. SynchronizedList和Vector的区别
Vector是java.util包中的一个类。 SynchronizedList是java.util.Collections中的一个静态内部类。
在多线程的场景中可以直接使用Vector类，也可以使用Collections.synchronizedList(List list)方法来返回一个线程安全的List。

1.Vector使用同步方法实现，synchronizedList使用同步代码块实现。 
2.两者的扩充数组容量方式不一样（两者的add方法在扩容方面的差别也就是ArrayList和Vector的差别。
1.同步代码块在锁定的范围上可能比同步方法要小，一般来说锁的范围大小和性能是成反比的。 2.同步块可以更加精确的控制锁的作用域（锁的作用域就是从锁被获取到其被释放的时间），同步方法的锁的作用域就是整个方法。 3.静态代码块可以选择对哪个对象加锁，但是静态方法只能给this对象加锁。

SynchronizedList和Vector最主要的区别： 1.SynchronizedList有很好的扩展和兼容功能。他可以将所有的List的子类转成线程安全的类。 2.使用SynchronizedList的时候，进行遍历时要手动进行同步处理。 3.SynchronizedList可以指定锁定的对象。

### 41. Arrays.asList获得的List使用时需要注意什么
Arrays.asList( a [] ) 是以底层的数组作为其物理实现，直接修改由此产生的list，底层的数组是会变化。另外这样产生的list的大小固定的，不能往其中新添元素！
基本类型不能作为泛型参数传入.如果需要,改成对应的包装类
Arrays.asList返回的是固定只读的ArrayList,如果后面可能会改变,慎用该方法.

### 42. List和原始类型List之间的区别?
List：原生态类型
List<Object>：参数化的类型，表明List中可以容纳任意类型的对象
List<?>：无限定通配符类型，表示只能包含某一种未知对象类型

原生态类型的含义是不带任何实际参数的泛型名称，例如Java 1.5后改为泛型实现的List<E>，List就是它的原生态类型，与没有引入泛型之前的类型完全一致。
如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。——Effective Java

### 43. List<?>和List之间的区别是什么?

### 44. synchronized是如何实现的？
Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的

### 45. BIO、NIO和AIO的区别、三种IO的用法与原理
BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。
NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。
AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

### 46. ConcurrentSkipListMap
concurrentHashMap与ConcurrentSkipListMap性能测试
在4线程1.6万数据的条件下，ConcurrentHashMap 存取速度是ConcurrentSkipListMap 的4倍左右。

但ConcurrentSkipListMap有几个ConcurrentHashMap 不能比拟的优点：

1、ConcurrentSkipListMap 的key是有序的。
2、ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap 的存取时间是log（N），和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出他的优势。 
ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够在O(log(n))时间内完成查找、插入、删除操作。
注意，调用ConcurrentSkipListMap的size时，由于多个线程可以同时对映射表进行操作，所以映射表需要遍历整个链表才能返回元素个数，这个操作是个O(log(n))的操作。

### 47. String.valueOf和Integer.toString的区别
 java.lang.Object类里已有public方法.toString()，所以对任何严格意义上的java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常。

而valueOf(Object obj)对null值进行了处理，不会报任何异常。但当object为null 时，String.valueOf（object）的值是字符串”null”，而不是null。

### 48. Integer的缓存机制
在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。
适用于整数值区间-128 至 +127。
只适用于自动装箱。使用构造函数创建对象不适用。

这种缓存行为不仅适用于Integer对象。我们针对所有的整数类型的类都有类似的缓存机制。

有ByteCache用于缓存Byte对象;
有ShortCache用于缓存Short对象;
有LongCache用于缓存Long对象;
有CharacterCache用于缓存Character对象.

Byte, Short, Long有固定范围: -128 到 127。对于Character, 范围是 0 到 127。除了Integer以外，这个范围都不能改变。

### 49. Set如何保证元素不重复?
因为HashMap在put一个Key时会判断，将要放进去的Key的hash值与 目前HashMap中定位到的那个Key的hash值比较。
如果hash值相当，继续比较 这两个对象的地址或者内容是否相当。
如果相当：判断出来要添加的Key与HashMap中的Key重复，把Value的值给替换成最新的。
HashSet中的Value是一个固定值PRESENT。 所以修改不修改无所谓。

### 50. Java中如何保证线程安全？
1. 最简单的方式是加入synchronized关键字，只要将操作共享数据的语句加入synchronized关键字，在某一时段只会让一个线程执行完，在执行过程中，其他线程不能进来执行。2. 锁。

区别：

a.Lock使用起来比较灵活，但需要手动释放和开启；采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；
b.Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；
c.在并发量比较小的情况下，使用synchronized是个不错的选择，但是在并发量比较高的情况下，其性能下降很严重，此时Lock是个不错的方案。
d.使用Lock的时候，等待/通知 是使用的Condition对象的await()/signal()/signalAll()  ，而使用synchronized的时候，则是对象的wait()/notify()/notifyAll();由此可以看出，使用Lock的时候，粒度更细了，一个Lock可以对应多个Condition。
e.虽然Lock缺少了synchronized隐式获取释放锁的便捷性，但是却拥有了锁获取与是释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized所不具备的同步特性;

